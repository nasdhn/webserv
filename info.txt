Doc :

https://www.geeksforgeeks.org/cpp/socket-programming-in-cpp/
https://blog.stephane-robert.info/docs/admin-serveurs/linux/curl/
https://medium.com/@avocadi/what-is-epoll-9bbc74272f7c
https://www.scaffoldgainford.com/blog/what-is-the-poll-function-for-sockets-311835.html




Requete :
Ligne de requete -> Methode / Target / Version HTTP
Header -> info sur la requete host, content type, cookie, taille body etc..
Montre comment interpreter la requete

Body -> Donnee envoye par le client
donnee pour CGI, upload un fichier, formulaire etc..

Reponse :
Ligne de statut -> Version HTTP / Code de statut / Message
Montre si la requete a reussi ou pas
Header -> decrit la reponse envoyee
content type, content lenght, loation etc..
Le navigateur utilise ca pour savoir comment interpreter le body

Body -> page html, fichier, image ou reponse cgi
C est le contenu de ce que le client recoit


A retirer et remplacer :
- recherche manuelle du /r/n/r/n
- le substr pour couper le header
- la recherche de content lenght
- la convertion pour avoir la taille
- la str body
- le header fake
- l affectation 
- le port 8080 que j aimis
- l adresse ip
- remplacer le 60 sec du timeout par la valeur parser


A faire :
- ajouter la possibili√© d'avoir plusieurs serveur - V
- faire les signaux - V
- le check ERRNO





Deroulement :

Phase 1 : Le D√©marrage (Le serveur s'installe)
Commande : ./webserv l.conf

main.cpp (suppos√©) parse le fichier conf et cr√©e un std::vector<Server>.

WebServ::WebServ (Constructeur) est appel√©.

Il boucle sur les serveurs.

Il appelle servInit("127.0.0.1", 8080).

socket() : Cr√©ation du File Descriptor (ex: FD 3).

fcntl(..., O_NONBLOCK) : Le socket ne bloquera jamais.

bind() : Il r√©serve le port 8080.

listen() : Il se met en mode √©coute.

Il ajoute ce FD 3 √† la liste _fd (pour poll) et au vecteur _serverSockets.

WebServ::setupServ d√©marre.

Il rentre dans la boucle while (sigPressed).

Il appelle poll() et s'endort en attendant qu'il se passe quelque chose.


Phase 2 : La Connexion (Le "Knock Knock")
Action : Tu tapes localhost:8080 dans ton navigateur.

Le navigateur envoie un paquet SYN (TCP).

poll() se r√©veille dans WebServ.cpp (ligne 137).

Il voit que FD 3 (le serveur) a re√ßu un √©v√©nement POLLIN.

Il v√©rifie isServerSocket(3) -> VRAI.

Il appelle accept() (ligne 151).

Cela cr√©e un nouveau socket d√©di√© √† ton navigateur (ex: FD 4).

Il met FD 4 en O_NONBLOCK.

Il cr√©e un objet new Client(4, this).

‚ö†Ô∏è √âtat Actuel (Client.cpp ligne 26) : Le constructeur remplit _response avec un message hardcod√© ("bonjour ok voila").

Il ajoute FD 4 √† la liste de poll (_fd) et √† la map _clients.

La boucle while recommence, poll() se rendort.


Phase 3 : La Requ√™te (Le Navigateur parle)
Action : Le navigateur envoie le texte : GET / HTTP/1.1 ...

poll() se r√©veille.

Il voit que FD 4 (le client) a un √©v√©nement POLLIN.

Il v√©rifie isServerSocket(4) -> FAUX.

Il appelle recv() (ligne 179).

Il lit les donn√©es brutes dans buffer.

Il appelle client->processRequest(buffer, ret).


Phase 4 : Le Cerveau (Client & Request) üß†
Lieu : Client.cpp

_request.parse(buffer) est appel√©.

La "Machine √† √©tats" de Request.cpp analyse le texte.

Elle extrait : Method: GET, Path: /, Version: HTTP/1.1.

Elle passe l'√©tat √† REQ_COMPLETE.

Client::processRequest reprend la main.

Il voit _request.isComplete() == true.

Le Routing commence :

findServer(...) : Trouve le bloc de config qui correspond au port 8080. Stocke dans _server.

findLocation(...) : Trouve la route /. Stocke dans _location.

V√©rifications de S√©curit√© :

Check MaxBodySize : OK (GET n'a pas de body).

Check MethodAllowed : OK (GET autoris√©).

G√©n√©ration de la R√©ponse :

Il affiche "Routing SUCCES...".

‚ö†Ô∏è C'est ici que le code s'arr√™te actuellement (ligne 137 de Client.cpp).

Il passe _readyToSend = true.

(Note : Dans la version finale, c'est ici qu'on appellera Response::execute de Yan).



Phase 5 : L'Envoi (La Livraison) üöö
Retour : WebServ.cpp (toujours dans la m√™me it√©ration de boucle)

Comme client->getReadyToSend() est vrai, WebServ modifie les √©v√©nements surveill√©s pour FD 4 :

_fd[i].events = POLLOUT | POLLIN (ligne 198).

La boucle while recommence.

poll() v√©rifie imm√©diatement si on peut √©crire sur FD 4.

R√©ponse : OUI (le tuyau est vide).

Il rentre dans le bloc if (revents & POLLOUT) (ligne 213).

Il appelle sendResponse(client, ...).

Il prend la string _response (celle hardcod√©e dans le constructeur pour l'instant).

Il appelle send().

Si tout est envoy√© :

Il affiche "Envoi termin√©".

Il remet _readyToSend = false.

Il remet pfd.events = POLLIN (pour √©couter une future requ√™te).